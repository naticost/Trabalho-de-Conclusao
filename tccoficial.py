# -*- coding: utf-8 -*-
"""TCCOFICIAL.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1X4QUCJ_fXEBpKmHfQBe9CGSDKWtm0JP4
"""

from google.colab import auth
auth.authenticate_user()

# Instalação de bibliotecas essenciais
!pip install --upgrade gspread pandas

import gspread
import pandas as pd
from google.auth import default

# Autenticação
creds, _ = default()
gc = gspread.authorize(creds)

# ID da sua planilha
sheet_id = '1udsbyOzI6d7vo1Sw_DHyicmfUldk1kY3-e0UUNrkgec'

sheet_name = 'Respostas ao formulário 1'

# Acessando a aba da planilha
worksheet = gc.open_by_key(sheet_id).worksheet(sheet_name)

# Obter todos os registros
data = worksheet.get_all_records()
df = pd.DataFrame(data)

# Exibir os primeiros registros
df.head()
print(df.info())

# Importando as bibliotecas necessárias
import pandas as pd
from scipy.stats import zscore
import numpy as np
import seaborn as sns
import matplotlib.pyplot as plt

# 1. Remover respostas duplicadas
df_no_duplicates = df.drop_duplicates()

# 2. Verificar valores ausentes por coluna
missing_values = df_no_duplicates.isnull().sum()
print("Valores ausentes por coluna:")
print(missing_values)

# Imputação com a média apenas nas colunas numéricas
numeric_cols = df_no_duplicates.select_dtypes(include=['float64', 'int64']).columns
df_no_duplicates[numeric_cols] = df_no_duplicates[numeric_cols].fillna(df_no_duplicates[numeric_cols].mean())

# 3. Identificação de outliers usando Z-score (apenas nas colunas numéricas)
z_scores = df_no_duplicates[numeric_cols].apply(zscore)
outliers = (z_scores.abs() > 3).sum()
print("Outliers identificados por coluna numérica:")
print(outliers)

# Exibir resumo final dos dados tratados
print("Dataset final, pronto para análise:")
df_no_duplicates.head()

# Definir mapeamento das subescalas com os nomes completos das colunas
subscales = {
    'Relação com utentes': [
        '2. Atitudes negativas relativamente ao nosso trabalho por parte das \npessoas a quem presto os meus serviços (ex: clientes, cidadãos, \netc.)',
        '8. Incompreensão face ao nosso trabalho por parte das pessoas a \nquem presto os meus serviços (ex: clientes, cidadãos, etc.)',
        '13. Cumprir com aquilo que é esperado pelas pessoas a quem presto \nos meus serviços (ex: clientes, cidadãos, etc.)',
        '21. Nível de exigência das pessoas a quem presto os meus serviços \n(ex: clientes, cidadãos, etc.)'
    ],
    'Relação com chefias': [
        '12. Conflitos e problemas com superiores hierárquicos',
        '20. A falta de apoio e ajuda por parte dos meus superiores',
        '24. O favoritismo e/ou discriminação “encobertos” no meu local de \ntrabalho por parte dos meus superiores'
    ],
    'Relação com colegas': [
        '4. Conflitos e problemas com colegas de trabalho',
        '17. Os conflitos interpessoais com outros colegas de trabalho',
        '22. Comportamentos incorretos e/ou inadequados de colegas de \ntrabalho'
    ],
    'Excesso de trabalho': [
        '5. Trabalhar muitas horas seguidas',
        '10. O excesso de trabalho e/ou tarefas de caráter burocrático',
        '11. Ter de realizar muitas horas seguidas de trabalho',
        '16. A sobrecarga ou excesso de trabalho'
    ],
    'Carreira e remuneração': [
        '1. A falta de possibilidades de desenvolvimento e promoção na \ncarreira',
        '6. Viver com os recursos financeiros/salário de que disponho',
        '15. Falta de perspetivas de progressão na carreira',
        '19. Salário inadequado/insuficiente'
    ],
    'Problemas familiares': [
        '3. Falta de tempo para manter uma boa relação com as pessoas mais \npróximas (ex: cônjuge, filhos, amigos, etc.)',
        '14. Falta de tempo para dar apoio e conviver com a minha \nfamília/amigos',
        '23. Falta de tempo para estar com a família/amigos'
    ],
    'Condições de trabalho': [
        '7. Falta de condições de trabalho',
        '9. Falta de materiais e equipamentos para realizar o meu trabalho',
        '18. Falta de meios e condições de trabalho'
    ]
}

# Função para calcular o índice de estresse de cada subescala com tratamento de valores não numéricos
def calculate_stress_index(row, items):
    values = []
    for item in items:
        if item in row:
            try:
                # converte o valor para float e adicione à lista de valores
                values.append(float(row[item]))
            except ValueError:
                # Ignora valores que não podem ser convertidos para float
                pass
    return sum(values) / len(values) if values else None

# Aplicando a função para cada subescala
for subscale, items in subscales.items():
    df[subscale] = df.apply(lambda row: calculate_stress_index(row, items), axis=1)

# Classificação dos níveis de estresse
def stress_level(score):
    if score <= 1:
        return 'Baixo'
    elif 1 < score <= 3:
        return 'Moderado'
    else:
        return 'Elevado'

# Aplicando a classificação para cada subescala
for subscale in subscales.keys():
    df[f"{subscale}_Nível"] = df[subscale].apply(stress_level)

# Exibindo as primeiras linhas para verificar
df.head()

# Salvar o DataFrame como CSV
df.to_csv('MANIPULADOindice_estresse.csv', index=False, encoding='utf-8-sig')

# Redefinindo o dicionário de subescalas
subscales = {
    'Relação com utentes': [
        '2. Atitudes negativas relativamente ao nosso trabalho por parte das \npessoas a quem presto os meus serviços (ex: clientes, cidadãos, \netc.)',
        '8. Incompreensão face ao nosso trabalho por parte das pessoas a \nquem presto os meus serviços (ex: clientes, cidadãos, etc.)',
        '13. Cumprir com aquilo que é esperado pelas pessoas a quem presto \nos meus serviços (ex: clientes, cidadãos, etc.)',
        '21. Nível de exigência das pessoas a quem presto os meus serviços \n(ex: clientes, cidadãos, etc.)'
    ],
    'Relação com chefias': [
        '12. Conflitos e problemas com superiores hierárquicos',
        '20. A falta de apoio e ajuda por parte dos meus superiores',
        '24. O favoritismo e/ou discriminação “encobertos” no meu local de \ntrabalho por parte dos meus superiores'
    ],
    'Relação com colegas': [
        '4. Conflitos e problemas com colegas de trabalho',
        '17. Os conflitos interpessoais com outros colegas de trabalho',
        '22. Comportamentos incorretos e/ou inadequados de colegas de \ntrabalho'
    ],
    'Excesso de trabalho': [
        '5. Trabalhar muitas horas seguidas',
        '10. O excesso de trabalho e/ou tarefas de caráter burocrático',
        '11. Ter de realizar muitas horas seguidas de trabalho',
        '16. A sobrecarga ou excesso de trabalho'
    ],
    'Carreira e remuneração': [
        '1. A falta de possibilidades de desenvolvimento e promoção na \ncarreira',
        '6. Viver com os recursos financeiros/salário de que disponho',
        '15. Falta de perspetivas de progressão na carreira',
        '19. Salário inadequado/insuficiente'
    ],
    'Problemas familiares': [
        '3. Falta de tempo para manter uma boa relação com as pessoas mais \npróximas (ex: cônjuge, filhos, amigos, etc.)',
        '14. Falta de tempo para dar apoio e conviver com a minha \nfamília/amigos',
        '23. Falta de tempo para estar com a família/amigos'
    ],
    'Condições de trabalho': [
        '7. Falta de condições de trabalho',
        '9. Falta de materiais e equipamentos para realizar o meu trabalho',
        '18. Falta de meios e condições de trabalho'
    ]
}

# Selecionar apenas as colunas de média das subescalas para a matriz de correlação
subscale_columns = list(subscales.keys())  # As chaves do dicionário são os nomes das subescalas
subscale_data = df[subscale_columns]

# Calcular a matriz de correlação
correlation_matrix = subscale_data.corr()

# Plotar a matriz de correlação para visualização
plt.figure(figsize=(10, 8))
sns.heatmap(correlation_matrix, annot=True, cmap='coolwarm', fmt=".2f", linewidths=0.5)
plt.title("Matriz de Correlação entre Dimensões de Estresse Ocupacional")
plt.show()

correlation_matrix

# Identificar as três profissões com o maior número de respostas
top_professions = df['Qual sua profissão?'].value_counts().nlargest(3).index

# Filtrar o DataFrame original para conter apenas as respostas das três profissões mais comuns
df_top_professions = df[df['Qual sua profissão?'].isin(top_professions)].copy()

# Adicionar a coluna 'Data' convertendo a coluna 'Carimbo de data/hora'
df_top_professions['Data'] = pd.to_datetime(df_top_professions['Carimbo de data/hora']).dt.date

# Repetir o cálculo da média de estresse das subescalas por data para cada uma das três profissões
stress_by_day = df_top_professions.groupby(['Data', 'Qual sua profissão?'])[list(subscales.keys())].mean().reset_index()

# Plotar a variação de estresse ao longo do mês para as três profissões mais comuns
plt.figure(figsize=(14, 8))

# Iterar sobre cada profissão e subescala para mostrar a variação de estresse
for profession in top_professions:
    profession_data = stress_by_day[stress_by_day['Qual sua profissão?'] == profession]
    plt.plot(profession_data['Data'], profession_data['Relação com utentes'], label=f'{profession} - Relação com utentes')
    plt.plot(profession_data['Data'], profession_data['Excesso de trabalho'], label=f'{profession} - Excesso de trabalho')
    # Adicione outras subescalas conforme necessário

plt.title("Variação do Estresse ao Longo do Mês para as Profissões Mais Frequentes")
plt.xlabel("Data")
plt.ylabel("Índice Médio de Estresse")
plt.legend(loc='upper right')
plt.xticks(rotation=45)
plt.tight_layout()
plt.show()

# Função para calcular o índice de estresse geral com base nas médias das subescalas
df['Índice de Estresse'] = df[list(subscales.keys())].mean(axis=1)

# Função para classificar o nível de estresse
def stress_level(score):
    if score <= 1:
        return 'Baixo'
    elif 1 < score <= 3:
        return 'Moderado'
    else:
        return 'Elevado'

# Aplicando a classificação
df['Nível de Estresse'] = df['Índice de Estresse'].apply(stress_level)

# Cálculo da correlação das variáveis com o Índice de Estresse
# Inclui apenas as colunas numéricas para evitar erros
numeric_df = df.select_dtypes(include=['float64', 'int64'])
correlation_with_stress_index = numeric_df.corr()['Índice de Estresse'].sort_values(ascending=False)

# Exibindo a correlação das variáveis com o índice de estresse
print("Correlação das variáveis com o Índice de Estresse:")
print(correlation_with_stress_index)

# Identificando e exibindo as variáveis que impactam diretamente o índice de estresse
print("\nVariáveis com maior impacto no Índice de Estresse:")
top_correlations = correlation_with_stress_index[correlation_with_stress_index > 0.7]  # Filtrando as mais impactantes
print(top_correlations)

# Explicação da ausência de correlações negativas ou zero
# No contexto deste questionário, todas as variáveis foram projetadas para medir fatores que contribuem para o estresse.
# Isso significa que pontuações mais altas em qualquer variável indicam maior estresse, levando a correlações positivas com o índice total.
# Além disso, nenhuma variável tem impacto contrário ou neutro em relação ao estresse, daí a ausência de valores negativos ou zero na matriz de correlação.

print(df.head())

# Selecionar apenas as subescalas mais impactantes para calcular e visualizar a correlação com o Índice de Estresse
impactful_subscales = ['Relação com utentes', 'Relação com chefias', 'Relação com colegas', 'Excesso de trabalho',
                       'Carreira e remuneração', 'Problemas familiares', 'Condições de trabalho', 'Índice de Estresse']

# Criar uma matriz de correlação somente com as variáveis mais impactantes e o Índice de Estresse
correlation_matrix_impactful = df[impactful_subscales].corr()

# Plotar a matriz de correlação com as variáveis mais impactantes
plt.figure(figsize=(10, 8))
sns.heatmap(correlation_matrix_impactful, annot=True, cmap='coolwarm', fmt=".2f", linewidths=0.5, square=True, cbar_kws={'shrink': .8})

# Título e ajustes visuais
plt.title("Matriz de Correlação das Variáveis Mais Impactantes com o Índice de Estresse", fontsize=16)
plt.xticks(rotation=45, ha='right', fontsize=12)
plt.yticks(fontsize=12)
plt.tight_layout()
plt.show()

# Exibir as primeiras linhas do DataFrame para confirmar os dados
df.head()

# Autenticação no Colab
from google.colab import auth
auth.authenticate_user()

# Instalação de bibliotecas essenciais
!pip install --upgrade gspread pandas google-cloud-bigquery pandas-gbq

import gspread
import pandas as pd
from google.auth import default
from google.cloud import bigquery
import numpy as np

# Configuração de autenticação e acesso à planilha
creds, _ = default()
gc = gspread.authorize(creds)

# ID e nome da aba da planilha
sheet_id = '1udsbyOzI6d7vo1Sw_DHyicmfUldk1kY3-e0UUNrkgec'
sheet_name = 'Respostas ao formulário 1'
worksheet = gc.open_by_key(sheet_id).worksheet(sheet_name)

# Obter todos os registros e carregar em um DataFrame
data = worksheet.get_all_records()
df = pd.DataFrame(data)

# Remover respostas duplicadas
df_no_duplicates = df.drop_duplicates()

# 1. Convertendo colunas para tipos compatíveis com BigQuery
# Converter colunas numéricas para float e strings para string
for col in df_no_duplicates.columns:
    if df_no_duplicates[col].dtype == 'object':
        # Tentar converter para numérico, se possível
        df_no_duplicates[col] = pd.to_numeric(df_no_duplicates[col], errors='ignore')
    # Forçar a conversão de qualquer coluna que ainda esteja como 'object' para 'string'
    if df_no_duplicates[col].dtype == 'object':
        df_no_duplicates[col] = df_no_duplicates[col].astype(str)

# 2. Preenchimento de valores ausentes
# Para colunas numéricas, preencha com a média; para colunas de texto, preencha com "Indefinido"
numeric_cols = df_no_duplicates.select_dtypes(include=['float64', 'int64']).columns
text_cols = df_no_duplicates.select_dtypes(include=['object']).columns

df_no_duplicates[numeric_cols] = df_no_duplicates[numeric_cols].fillna(df_no_duplicates[numeric_cols].mean())
df_no_duplicates[text_cols] = df_no_duplicates[text_cols].fillna('Indefinido')

# 3. Conversão de coluna de data, se houver
if 'Carimbo_de_data_hora' in df_no_duplicates.columns:
    df_no_duplicates['Carimbo_de_data_hora'] = pd.to_datetime(df_no_duplicates['Carimbo_de_data_hora'], errors='coerce')

# 4. Renomear as colunas para um formato compatível com BigQuery
df_no_duplicates.columns = df_no_duplicates.columns.str.replace('[^0-9a-zA-Z]+', '_', regex=True)

# Configuração do BigQuery
client = bigquery.Client(project='bubbly-observer-435519-r6')
dataset_id = 'seu_dataset'  # Substitua pelo nome do dataset no BigQuery
table_id = 'sua_tabela'  # Substitua pelo nome da tabela no BigQuery

# Verifique se o dataset existe e crie-o se necessário
dataset_ref = client.dataset(dataset_id)
try:
    client.get_dataset(dataset_ref)
    print("Dataset já existe")
except:
    dataset = bigquery.Dataset(dataset_ref)
    dataset.location = "US"
    client.create_dataset(dataset)
    print("Dataset criado com sucesso")

# 5. Enviar o DataFrame tratado para o BigQuery
try:
    from pandas_gbq import to_gbq  # Use pandas_gbq para evitar o aviso de depreciação
    to_gbq(df_no_duplicates, destination_table=f"{dataset_id}.{table_id}",
           project_id='bubbly-observer-435519-r6', if_exists='replace')
    print("Dados enviados com sucesso para o BigQuery.")
except Exception as e:
    print(f"Erro ao enviar dados para o BigQuery: {e}")

print(df.columns)

subscales = {
    'Relação com utentes': [
        '2. Atitudes negativas relativamente ao nosso trabalho por parte das \npessoas a quem presto os meus serviços (ex: clientes, cidadãos, \netc.)',
        '8. Incompreensão face ao nosso trabalho por parte das pessoas a \nquem presto os meus serviços (ex: clientes, cidadãos, etc.)',
        '13. Cumprir com aquilo que é esperado pelas pessoas a quem presto \nos meus serviços (ex: clientes, cidadãos, etc.)',
        '21. Nível de exigência das pessoas a quem presto os meus serviços \n(ex: clientes, cidadãos, etc.)'
    ],
    'Relação com chefias': [
        '12. Conflitos e problemas com superiores hierárquicos',
        '20. A falta de apoio e ajuda por parte dos meus superiores',
        '24. O favoritismo e/ou discriminação “encobertos” no meu local de \ntrabalho por parte dos meus superiores'
    ],
    'Relação com colegas': [
        '4. Conflitos e problemas com colegas de trabalho',
        '17. Os conflitos interpessoais com outros colegas de trabalho',
        '22. Comportamentos incorretos e/ou inadequados de colegas de \ntrabalho'
    ],
    'Excesso de trabalho': [
        '5. Trabalhar muitas horas seguidas',
        '10. O excesso de trabalho e/ou tarefas de caráter burocrático',
        '11. Ter de realizar muitas horas seguidas de trabalho',
        '16. A sobrecarga ou excesso de trabalho'
    ],
    'Carreira e remuneração': [
        '1. A falta de possibilidades de desenvolvimento e promoção na \ncarreira',
        '6. Viver com os recursos financeiros/salário de que disponho',
        '15. Falta de perspetivas de progressão na carreira',
        '19. Salário inadequado/insuficiente'
    ],
    'Problemas familiares': [
        '3. Falta de tempo para manter uma boa relação com as pessoas mais \npróximas (ex: cônjuge, filhos, amigos, etc.)',
        '14. Falta de tempo para dar apoio e conviver com a minha \nfamília/amigos',
        '23. Falta de tempo para estar com a família/amigos'
    ],
    'Condições de trabalho': [
        '7. Falta de condições de trabalho',
        '9. Falta de materiais e equipamentos para realizar o meu trabalho',
        '18. Falta de meios e condições de trabalho'
    ]
}
# Função para tentar converter valores para float, retornando NaN se não for possível
def to_numeric(value):
    try:
        return float(value)
    except ValueError:
        return np.nan

# Aplicar a função para converter as colunas das subescalas
for subscale, items in subscales.items():
    df[items] = df[items].applymap(to_numeric)
    df[subscale] = df[items].mean(axis=1)

# Calcular o Índice de Estresse como a média das subescalas
df['Índice de Estresse'] = df[list(subscales.keys())].mean(axis=1)

# Classificação dos níveis de estresse
def stress_level(score):
    if score <= 1:
        return 'Baixo'
    elif 1 < score <= 3:
        return 'Moderado'
    else:
        return 'Elevado'

# Aplicando a classificação para o Índice de Estresse
df['Nível de Estresse'] = df['Índice de Estresse'].apply(stress_level)

# Exibindo as primeiras linhas para verificar o resultado
df[['Qual sua profissão?', 'Índice de Estresse', 'Nível de Estresse']].head()

import pandas as pd

#Carregar o arquivo CSV original, se necessário
df_final = pd.read_csv('/content/MANIPULADOindice_estresse.csv')

# Substituir caracteres especiais e espaços nos nomes das colunas
df_final.columns = df_final.columns.str.normalize('NFKD')  # Remove acentos
df_final.columns = df_final.columns.str.replace('[^\w\s]', '', regex=True)  # Remove caracteres especiais
df_final.columns = df_final.columns.str.replace('\s+', '_', regex=True)  # Substitui espaços por underscores

# Certifique-se de que os tipos de dados estão corretos
# Caso alguma coluna esteja incorretamente tipada, ajuste-a aqui
# Exemplo: df_final['Indice_de_Estresse'] = pd.to_numeric(df_final['Indice_de_Estresse'], errors='coerce')

# Salvar o DataFrame atualizado como um arquivo CSV em um caminho fácil de encontrar
output_path = 'indice_estresse_profissao_tratado_final.csv'
df_final.to_csv(output_path, index=False)

output_path  # Exibe o caminho do arquivo para download

print(df.head())